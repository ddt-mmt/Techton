#!/bin/bash

# ==============================================================================
# TECHTON - Enterprise Active Directory Stress Testing Suite
# Version: 1.0 (Hybrid: Docker + Local Host Mode)
# Property of: Badan Riset dan Inovasi Nasional (BRIN)
# License: MIT
# ==============================================================================

# --- CONFIGURATION ---
RETENTION_DAYS=30
DOCKER_IMAGE_JM="justb4/jmeter:5.5"
DOCKER_IMAGE_K6="techton-k6:latest"
JVM_ARGS="-Xms1g -Xmx4g" # JMeter Memory

# --- ENVIRONMENT SETUP ---
SOURCE=${BASH_SOURCE[0]}
while [ -L "$SOURCE" ]; do
  DIR=$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )
  SOURCE=$(readlink "$SOURCE")
  [[ $SOURCE != /* ]] && SOURCE=$DIR/$SOURCE
done
BIN_DIR=$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )
PROJECT_ROOT="$(dirname "$BIN_DIR")"
LOCAL_K6="$BIN_DIR/k6"

# Templates
TEMPLATE_JM_LOGIN="$PROJECT_ROOT/templates/ad_load.jmx"
TEMPLATE_JM_SEARCH="$PROJECT_ROOT/templates/ad_search.jmx"
TEMPLATE_K6_LOGIN="$PROJECT_ROOT/templates/ad_load_k6.js"

RESULTS_DIR="$PROJECT_ROOT/results"
HISTORY_FILE="$RESULTS_DIR/history.csv"
RUN_FILE_JMX="$RESULTS_DIR/run_current.jmx"
RUN_FILE_JS="$RESULTS_DIR/run_current.js"
TEMP_LOG="/tmp/techton_out.txt"

# --- HUD PALETTE ---
BOLD='\033[1m'
CLR_CYAN='\033[38;5;51m'
CLR_MAGENTA='\033[38;5;201m'
CLR_GREEN='\033[38;5;82m'
CLR_YELLOW='\033[38;5;226m'
CLR_RED='\033[38;5;196m'
CLR_GREY='\033[38;5;244m'
CLR_WHITE='\033[38;5;255m'
NC='\033[0m'

mkdir -p "$RESULTS_DIR"
if [ ! -f "$HISTORY_FILE" ]; then
    echo "Timestamp,Target,Mode,Users,Duration,AvgLatency,Errors,Status,Path" > "$HISTORY_FILE"
fi

# --- UTILS ---
cleanup() {
    tput cnorm
    if docker ps -q --filter "name=techton_" | grep -q .; then
        echo -e "\n ${CLR_RED}[!] EMERGENCY STOP: Killing active containers...${NC}"
        docker ps -q --filter "name=techton_" | xargs -r docker stop &> /dev/null
    fi
    # Also kill local k6
    pkill -f "$LOCAL_K6"
    
    [ -f "$RUN_FILE_JMX" ] && rm -f "$RUN_FILE_JMX"
    [ -f "$RUN_FILE_JS" ] && rm -f "$RUN_FILE_JS"
    [ -f "$TEMP_LOG" ] && rm -f "$TEMP_LOG"
    echo -e "\n ${CLR_GREY}System Terminated Safely.${NC}"
    exit 0
}
trap cleanup SIGINT SIGTERM

perform_housekeeping() {
    count=$(find "$RESULTS_DIR" -mindepth 1 -maxdepth 1 -type d -mtime +$RETENTION_DAYS | wc -l)
    if [ "$count" -gt 0 ]; then
        echo -e "${CLR_GREY} System Maintenance: Cleaning $count expired logs...${NC}"
        find "$RESULTS_DIR" -mindepth 1 -maxdepth 1 -type d -mtime +$RETENTION_DAYS -exec rm -rf {} +
    fi
}

draw_banner() {
    clear
    echo -e "${CLR_CYAN}â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
    echo -e "â”‚ ${BOLD}${CLR_WHITE}TECHTON ${CLR_CYAN}v1.0${NC}${CLR_CYAN}                                                       â”‚"
    echo -e "â”‚ ${CLR_GREY}Enterprise Grade Active Directory Resilience Audit Tool              ${CLR_CYAN}â”‚"
    echo -e "â”‚ ${CLR_GREY}Property of National Research and Innovation Agency (BRIN)         ${CLR_CYAN}â”‚"
    echo -e "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${NC}"
}

draw_main_menu() {
    draw_banner
    echo -e "\n ${BOLD}${CLR_WHITE}MAIN OPERATIONAL INTERFACE${NC}"
    echo -e " ${CLR_GREY}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
    echo -e "  ${CLR_CYAN}[1]${NC} INITIALIZE NEW ATTACK VECTOR"
    echo -e "  ${CLR_CYAN}[2]${NC} ACCESS HISTORICAL AUDIT LOGS"
    echo -e "  ${CLR_CYAN}[3]${NC} MONITOR ACTIVE SUB-PROCESSES"
    echo -e "  ${CLR_CYAN}[q]${NC} QUIT SYSTEM"
    echo -e "\n ${CLR_GREY}Select option...${NC}"
    printf " ${BOLD}${CLR_CYAN}>> ${NC}"
}

# --- MODULES ---
view_history() {
    while true;
    do
        draw_banner
        echo -e "\n ${BOLD}${CLR_WHITE}HISTORICAL AUDIT LOGS${NC}"
        echo -e " ${CLR_GREY}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
        printf " ${BOLD}${CLR_CYAN}%-3s  %-19s  %-15s  %-8s  %-8s  %-8s  %-8s${NC}\n" "ID" "TIMESTAMP" "TARGET" "MODE" "LOAD" "LATENCY" "STATUS"
        echo -e " ${CLR_GREY}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
        
        mapfile -t lines < <(tail -n +2 "$HISTORY_FILE")
        if [ ${#lines[@]} -eq 0 ]; then
            echo -e " ${CLR_YELLOW}No records found in database.${NC}"
        else
            i=1
            declare -A history_map
            for line in "${lines[@]}"; do
                IFS=',' read -r ts target mode users dur lat err stat path <<< "$line"
                # Compatibility check
                if [ -z "$path" ]; then path=$stat; stat=$err; err=$lat; lat=$dur; dur=$users; users=$mode; mode="LOGIN"; fi
                
                                                # Format Timestamp (YYYY-MM-DD HH:MM:SS)
                                                # If timestamp has underscores (old format), clean it. Else use as is.
                                                clean_ts=$(echo "$ts" | sed 's/_/ /g' | sed 's/\([0-9]\{2\}\)-\([0-9]\{2\}\)-\([0-9]\{2\}\)/\1:\2:\3/')                                
                                status_display="$stat"
                                if [ ! -d "$path" ]; then status_display=$(echo -e "${CLR_GREY}EXPIRED${NC}"); 
                                else
                                     case "$stat" in
                                        PASS)  status_display=$(echo -e "${CLR_GREEN}${stat}${NC}") ;;
                                        WARN)  status_display=$(echo -e "${CLR_YELLOW}${stat}${NC}") ;;
                                        *)     status_display=$(echo -e "${CLR_RED}${stat}${NC}") ;;
                                    esac
                                fi
                                printf " ${CLR_CYAN}%02d${NC}   %-19s  %-15s  %-8s  %-8s  %-8s  %b\n" "$i" "$clean_ts" "$target" "$mode" "$users" "${lat}ms" "$status_display"                
                # Save for selection
                history_map[$i]="$line"
                ((i++))
            done
        fi
        echo -e "\n ${CLR_GREY}Enter ID for detailed report or [b] to Back...${NC}"
        printf " ${BOLD}${CLR_CYAN}>> ${NC}"
        read choice
        [[ "$choice" == "b" || "$choice" == "q" ]] && return
        
        # Detail View Logic
        if [[ -n "${history_map[$choice]}" ]]; then
            IFS=',' read -r ts target mode users dur lat err stat path <<< "${history_map[$choice]}"
            # Compatibility check again
            if [ -z "$path" ]; then path=$stat; fi
            
            echo -e "\n ${BOLD}${CLR_WHITE}REPORT DETAIL: #$choice${NC}"
            echo -e " ${CLR_GREY}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
            echo -e " Timestamp : $ts"
            echo -e " Target    : $target"
            echo -e " Mode      : $mode"
            echo -e " Status    : $stat"
            echo -e " Path      : $path"
            
            if [ -d "$path" ]; then
                echo -e "\n ${BOLD}${CLR_WHITE}ðŸ“Š DATA ANALYSIS${NC}"
                echo -e " ${CLR_GREY}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
                
                # JMETER ANALYSIS (CSV)
                if [ -f "$path/result.jtl" ]; then
                    echo -e " Engine: ${CLR_CYAN}Apache JMeter${NC}"
                    awk -F',' '
                        BEGIN { count=0; sum=0; max=0; err=0; }
                        NR>1 {
                            count++;
                            t=$2; # Elapsed/Latency
                            sum+=t;
                            if(t>max) max=t;
                            if($8 == "false") err++;
                        }
                        END {
                            if(count>0) {
                                avg = sum/count;
                                err_rate = (err/count)*100;
                                printf " Total Requests  : %d\n", count
                                printf " Avg Latency     : %.2f ms\n", avg
                                printf " Max Latency     : %.2f ms\n", max
                                printf " Error Rate      : %.2f%%\n", err_rate
                                
                                if (avg > 2000) print " \033[31m[!] CRITICAL: High Latency (>2s)\033[0m"
                                else if (avg > 500) print " \033[33m[!] WARNING: Moderate Latency (>500ms)\033[0m"
                                else print " \033[32m[OK] Latency is healthy\033[0m"
                            } else {
                                print " No data points found."
                            }
                        }
                    ' "$path/result.jtl"
                    
                # K6 ANALYSIS (Log Parsing)
                elif [ -f "$path/execution.log" ] && grep -q "k6" "$path/execution.log"; then
                    echo -e " Engine: ${CLR_CYAN}K6 (Go)${NC}"
                    # Extract Summary Stats
                    grep -A 10 "iteration_duration..." "$path/execution.log" | sed 's/^/ /'
                    grep "iterations..........." "$path/execution.log" | sed 's/^/ /'
                    echo ""
                    
                    # Check for Critical Errors
                    errs=$(grep -c "ERRO" "$path/execution.log")
                    if [ "$errs" -gt 0 ]; then
                        echo -e " ${CLR_RED}[!] Found $errs Critical Errors in log.${NC}"
                        grep "ERRO" "$path/execution.log" | head -n 3 | sed 's/^/   /'
                    else
                        echo -e " ${CLR_GREEN}[OK] No critical errors found.${NC}"
                    fi
                else
                    echo -e " ${CLR_YELLOW}[!] Analysis data not available (Log missing).${NC}"
                fi

                echo -e "\n ${BOLD}ðŸ“‚ Artifacts:${NC}"
                ls -1 "$path" | sed 's/^/  - /'
                echo -e "\n ${CLR_GREEN}Tip: Use SCP to download reports for full details.${NC}"
            else
                 echo -e "\n ${CLR_RED}[!] Logs for this run have been deleted/expired.${NC}"
            fi
            read -p " Press Enter..."
        fi
    done
}

check_processes() {
    draw_banner
    echo -e "\n ${BOLD}${CLR_WHITE}SYSTEM PROCESS MONITOR${NC}"
    echo -e " ${CLR_GREY}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
    active=$(docker ps --format "table {{.Names}}\t{{.Status}}" | grep "techton")
    local_proc=$(pgrep -a k6)
    
    if [ -z "$active" ] && [ -z "$local_proc" ]; then 
        echo -e " ${CLR_GREEN}System status: Nominal.${NC}"
    else
        echo -e " ${CLR_RED}Active sessions:${NC}"
        [ ! -z "$active" ] && echo "$active"
        [ ! -z "$local_proc" ] && echo "Local K6 PID: $local_proc"
        
        read -p " Terminate? (y/n): " k
        if [[ "$k" == "y" ]]; then 
            docker ps -q --filter "name=techton" | xargs -r docker stop &>/dev/null
            pkill -f "$LOCAL_K6"
            echo -e " ${CLR_GREEN}Terminated.${NC}"
        fi
    fi
    read -p " Enter to return..."
}

ensure_k6_image() {
    if [[ "$(docker images -q $DOCKER_IMAGE_K6 2> /dev/null)" == "" ]]; then
        echo -e "\n ${CLR_YELLOW}[!] K6 Image ($DOCKER_IMAGE_K6) not found.${NC}"
        echo -e " ${CLR_GREY}Building it now (this may take a few minutes)...${NC}"
        docker build -t "$DOCKER_IMAGE_K6" -f "$PROJECT_ROOT/docker/Dockerfile" "$PROJECT_ROOT/docker"
        if [ $? -ne 0 ]; then
            echo -e "\n ${CLR_RED}[X] Build Failed.${NC} Please check Dockerfile or network."
            read -p " Press Enter..."
            return 1
        fi
        echo -e " ${CLR_GREEN}Build Success!${NC}"
    fi
    return 0
}

start_test() {
    draw_banner
    echo -e "\n ${BOLD}${CLR_WHITE}ATTACK VECTOR INITIALIZATION${NC}"
    echo -e " ${CLR_GREY}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
    
    # 0. Select Environment
    echo -e " ${CLR_WHITE}Select Environment:${NC}"
    echo -e " ${CLR_CYAN}[1]${NC} Docker Container (Isolated, Recommended)"
    echo -e " ${CLR_CYAN}[2]${NC} Host / Local System (Direct Network Access)"
    printf " ${BOLD}${CLR_CYAN}>> ${NC}"
    read env_choice
    env_choice=${env_choice:-1}
    
    # 1. Select Engine
    echo -e "\n ${CLR_WHITE}Select Engine:${NC}"
    if [[ "$env_choice" == "1" ]]; then
        echo -e " ${CLR_CYAN}[1]${NC} Apache JMeter (Standard)"
    fi
    echo -e " ${CLR_CYAN}[2]${NC} K6 (Experimental, Go-based, High Performance)"
    printf " ${BOLD}${CLR_CYAN}>> ${NC}"
    read engine_choice
    engine_choice=${engine_choice:-1}
    if [[ "$env_choice" == "2" ]]; then engine_choice=2; fi # Force K6 for Local if JMeter not setup

    # 2. Select Attack Mode
    echo -e "\n ${CLR_WHITE}Select Mode:${NC}"
    echo -e " ${CLR_CYAN}[1]${NC} AUTHENTICATION STORM (CPU Stress) - Simulates Boot Storm"
    if [[ "$engine_choice" == "1" ]]; then
        echo -e " ${CLR_CYAN}[2]${NC} DIRECTORY SEARCH     (RAM Stress) - Simulates Query Load"
    fi
    printf " ${BOLD}${CLR_CYAN}>> ${NC}"
    read mode_choice
    
    TEMPLATE_USE="$TEMPLATE_JM_LOGIN"
    MODE_NAME="LOGIN"
    
    if [[ "$engine_choice" == "1" ]]; then
        if [[ "$mode_choice" == "2" ]]; then TEMPLATE_USE="$TEMPLATE_JM_SEARCH"; MODE_NAME="SEARCH"; fi
    else
        TEMPLATE_USE="$TEMPLATE_K6_LOGIN"
        MODE_NAME="LOGIN-K6"
        if [[ "$env_choice" == "1" ]]; then
            ensure_k6_image || return
        else
            if [ ! -f "$LOCAL_K6" ]; then
                echo -e "\n ${CLR_RED}[X] Local K6 binary not found at $LOCAL_K6.${NC}"
                read -p " Press Enter..."
                return
            fi
        fi
    fi
    
    # Inputs with clearer examples
    echo -e "\n ${BOLD}${CLR_WHITE}TARGET CONFIGURATION ($MODE_NAME)${NC}"
    
    # Target IP
    printf " ${CLR_WHITE}Target IP${NC} [Ex: 192.168.1.10 or ad.corp.local]\n"
    printf " ${CLR_GREY}Default [192.168.100.236]: ${NC}"
    read t_ip
    t_ip=${t_ip:-192.168.100.236}
    
    # Admin Account
    printf "\n ${CLR_WHITE}Target User Account${NC} (Standard User is safer)
"
    printf " ${CLR_GREY}Default [tester]: ${NC}"
    read u_name
    u_name=${u_name:-tester}
    
    # DN Configuration
    printf "\n ${CLR_WHITE}Distinguished Name (DN) Configuration${NC}
"
    printf " ${CLR_CYAN}[1]${NC} Auto-Generate: CN=$u_name,OU=User,OU=BRIN,DC=net,DC=brin,DC=go,DC=id\n"
    printf " ${CLR_CYAN}[2]${NC} Manual Input
"
    printf " ${CLR_GREY}Select [1]: ${NC}"
    read dn_choice
    dn_choice=${dn_choice:-1}
    
    if [[ "$dn_choice" == "1" ]]; then
        u_dn="CN=$u_name,OU=User,OU=BRIN,DC=net,DC=brin,DC=go,DC=id"
    else
        printf " ${CLR_WHITE}Enter Full DN:${NC} "
        read u_dn
    fi
    echo -e " ${CLR_GREEN}Using DN:${NC} $u_dn"
    
    # Password
    printf "\n ${CLR_WHITE}Password${NC} (Input Hidden): "
    read -s pass
    echo ""
    
    # Load Intensity
    printf "\n ${CLR_WHITE}Concurrent Users (Threads)${NC}
"
    printf " ${CLR_GREY}Default [10]: ${NC}"
    read threads
    threads=${threads:-10}
    
    # Duration
    rampup=$((threads / 5)); [ $rampup -lt 1 ] && rampup=1
    rec_dur=$((rampup + 60))
    printf "\n ${CLR_WHITE}Attack Duration (Seconds)${NC}
"
    printf " ${CLR_GREY}Recommended Min [$rec_dur]: ${NC}"
    read dur_in
    duration=${dur_in:-$rec_dur}
    
    echo -e "\n ${CLR_CYAN}SYSTEM READY. ENGAGE?${NC}"
    read -p " Press Enter..."
    
    TS=$(date +"%Y-%m-%d_%H-%M-%S")
    LOG_TS=$(date +"%Y-%m-%d %H:%M:%S")
    CONTAINER_NAME="techton_${TS//[:_-]/}"
    R_DIR="run_${TS}_${threads}u"
    C_R_DIR="$RESULTS_DIR/$R_DIR"
    mkdir -p "$C_R_DIR"

    # Execution Logic
    if [[ "$engine_choice" == "1" ]]; then
        # JMETER (DOCKER) LOGIC
        sed -e "s/__TARGET_IP__/$t_ip/g" -e "s/__ROOT_DN__/DC=net,DC=brin,DC=go,DC=id/g" \
            -e "s/__USER_DN__/$u_dn/g" -e "s/__PASSWORD__/$pass/g" \
            -e "s/__THREADS__/$threads/g" -e "s/__RAMPUP__/$rampup/g" \
            -e "s/__DURATION__/$duration/g" "$TEMPLATE_USE" > "$RUN_FILE_JMX"

        tput civis
        docker run --rm --name "$CONTAINER_NAME" --dns "$t_ip" \
          --memory="4g" --cpus="2.0" \
          -e JVM_ARGS="$JVM_ARGS" \
          -v "$PROJECT_ROOT:/tests" -w /tests \
          $DOCKER_IMAGE_JM -Jsummariser.interval=3 -n -t "results/run_current.jmx" \
          -l "results/$R_DIR/result.jtl" -e -o "results/$R_DIR/dashboard" 2>&1 | tee "$TEMP_LOG" | \
          awk -v target="$t_ip" -v users="$threads" -v duration="$duration" -v mode="$MODE_NAME" \
              -v c1="$CLR_CYAN" -v c2="$CLR_MAGENTA" -v c3="$CLR_GREEN" -v c4="$CLR_RED" \
              -v c5="$CLR_YELLOW" -v c6="$CLR_GREY" -v c7="$CLR_WHITE" -v nc="$NC" -v b="$BOLD" \
        ' 
          BEGIN { start = systime() }
          /summary \+ / {
              now = systime(); elapsed = now - start; if(elapsed>duration) elapsed=duration;
              pct = (elapsed/duration)*100; if(pct>100) pct=100;
              bw=50; f=int((pct/100)*bw); bar=""; for(i=0;i<f;i++) bar=bar "â–ˆ"; for(i=f;i<bw;i++) bar=bar "â–‘";
              spd="0/s"; lat="0"; err="0";
              for(i=1;i<=NF;i++){ if($i ~ /\/s$/) spd=$i; if($i=="Avg:") lat=$(i+1); if($i=="Err:") err=$(i+1); }
              printf "\033[2J\033[H"
              print c1 "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
              print "â”‚ " b c7 "OPERATIONAL DASHBOARD (JMETER)" nc c1 "                                    â”‚"
              print "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤"
              printf "â”‚  %-12s %-18s  %-10s %-20s â”‚\n", "TARGET:", target, "MODE:", mode
              printf "â”‚  %-12s %-18s  %-10s %-20s â”‚\n", "LOAD:", users " THREADS", "DURATION:", duration "s"
              print "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤"
              print "â”‚    %-18s      %-18s      %-18s  |\n", "THROUGHPUT", "LATENCY", "ERROR COUNT"
              printf "â”‚    " c5 "%-18s" nc "      " c2 "%-18s" nc "      " (err>0?c4:c3) "% -18s" nc "  |\n", spd, lat " ms", err
              print "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤"
              printf "â”‚  PROGRESS: %3d%%  " c1 "[%s]" nc "  %4ds / %-4ds |\n", pct, bar, elapsed, duration
              print "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
              fflush()
          }
        '
        tput cnorm
        res=$(grep "summary =" "$TEMP_LOG" | tail -n 1)
        l=$(echo "$res" | awk -F 'Avg: ' '{print $2}' | awk '{print $1}'); l=${l:-0}
        e=$(echo "$res" | awk -F 'Err: ' '{print $2}' | awk '{print $1}'); e=${e:-0}
        
    else
        # K6 LOGIC (HOST OR DOCKER)
        sed -e "s/__TARGET_IP__/$t_ip/g" \
            -e "s/__USER_DN__/$u_dn/g" -e "s/__PASSWORD__/$pass/g" \
            -e "s/__THREADS__/$threads/g" -e "s/__RAMPUP__/$rampup/g" \
            -e "s/__DURATION__/$duration/g" "$TEMPLATE_USE" > "$RUN_FILE_JS"

        echo -e "${CLR_CYAN}Launching K6 ($env_choice)...${NC}"
        
        # Prepare command based on env
        if [[ "$env_choice" == "1" ]]; then
             CMD="docker run --rm --name $CONTAINER_NAME --dns $t_ip -v $PROJECT_ROOT:/tests $DOCKER_IMAGE_K6 run results/run_current.js"
        else
             CMD="$LOCAL_K6 run $RUN_FILE_JS"
        fi

        # Execute with Real-time Parsing for Dashboard using unbuffer/script trick or direct pipe
        # We use 'script' to trick K6 into outputting color and progress if needed, but K6 default stdout is fine for awk
        
        # Note: K6 outputs stats to stderr usually, so we redirect 2>&1
        $CMD 2>&1 | tee "$TEMP_LOG" | \
        awk -v target="$t_ip" -v users="$threads" -v duration="$duration" -v mode="$MODE_NAME" \
              -v c1="$CLR_CYAN" -v c2="$CLR_MAGENTA" -v c3="$CLR_GREEN" -v c4="$CLR_RED" \
              -v c5="$CLR_YELLOW" -v c6="$CLR_GREY" -v c7="$CLR_WHITE" -v nc="$NC" -v b="$BOLD" \
        '
        BEGIN { start = systime(); status="INITIALIZING"; }
        {
            # K6 Output Parsing Logic
            # K6 standard output updates look like: "running (1m20.5s), 500/1000 VUs, 4500 complete ..."
            
            if ($0 ~ /running \(/) {
                # Extract Elapsed Time (Format: 0m05.0s or 1m20.0s)
                match($0, /running \(([0-9]+)m([0-9.]+)s\)/, t)
                if (t[1] != "") elapsed = (t[1] * 60) + t[2]
                else elapsed = systime() - start
                
                # Cap elapsed at duration for bar calculation
                if (elapsed > duration) pct = 100
                else pct = (elapsed/duration)*100
                if(pct>100) pct=100
                
                # Extract VUs
                match($0, /([0-9]+)\/[0-9]+ VUs/, v)
                current_vus = v[1] ? v[1] : 0
                
                # Extract Iterations (Throughput approx)
                match($0, /([0-9]+) complete/, iter)
                iters = iter[1] ? iter[1] : 0

                # Render Dashboard
                bw=50; f=int((pct/100)*bw); bar=""; for(i=0;i<f;i++) bar=bar "â–ˆ"; for(i=f;i<bw;i++) bar=bar "â–‘";
                
                # Clear Screen (ANSI)
                printf "\033[2J\033[H"
                
                print c1 "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
                print "â”‚ " b c7 "OPERATIONAL DASHBOARD (K6 ENGINE)" nc c1 "                                 â”‚"
                print "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤"
                printf "â”‚  %-12s %-18s  %-10s %-20s â”‚\n", "TARGET:", target, "MODE:", mode
                printf "â”‚  %-12s %-18s  %-10s %-20s â”‚\n", "LOAD:", users " THREADS", "DURATION:", duration "s"
                print "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤"
                printf "â”‚    %-18s      %-18s      %-18s  |\n", "ACTIVE VUs", "ELAPSED", "ITERATIONS"
                printf "â”‚    " c5 "%-18s" nc "      " c2 "%-18s" nc "      " c3 "%-18s" nc "  |\n", current_vus, int(elapsed) "s", iters
                print "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤"
                printf "â”‚  PROGRESS: %3d%%  " c1 "[%s]" nc "  %4ds / %-4ds |\n", pct, bar, elapsed, duration
                print "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
                
                # Print any critical errors below the dashboard
                if ($0 ~ /ERRO/) {
                   print "\n " c4 $0 nc
                }
                
                fflush()
            }
            # Capture final summary stats for history
            if ($0 ~ /iterations\.\.\./) { 
                # iterations...........: 274  19.79118/s
                split($0, a, " "); 
                # Trying to catch the summary line
            }
        }
        END { print "\n" }
        ' 
    fi

    s="PASS"; [ "$e" -gt 0 ] && s="FAIL"; [ "$s" == "PASS" ] && [ "$l" -gt 2000 ] && s="CRIT"; [ "$s" == "PASS" ] && [ "$l" -gt 500 ] && s="WARN";
    
    # Save Execution Log for Analysis
    cp "$TEMP_LOG" "$C_R_DIR/execution.log"
    
    echo "$LOG_TS,$t_ip,$MODE_NAME,$threads,$duration,$l,$e,$s,$C_R_DIR" >> "$HISTORY_FILE"
    echo -e "\n ${BOLD}${CLR_WHITE}MISSION COMPLETE.${NC} STATUS: ${BOLD}$s${NC}"
    read -p " Press Enter to return..."
}

perform_housekeeping
while true; do
    draw_main_menu
    read choice
    case "$choice" in
        1) start_test ;; 2) view_history ;; 3) check_processes ;; q|Q) echo -e "\n${CLR_GREY}System Terminated.${NC}"; exit 0 ;;
    esac
done